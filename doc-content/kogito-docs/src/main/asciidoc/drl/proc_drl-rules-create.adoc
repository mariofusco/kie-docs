[id='proc_drl-rules-central-create_{context}']
= Creating DRL rules for your {PRODUCT} project

You can create and manage DRL rules for your {PRODUCT} project in your integrated development environment (IDE). For {PRODUCT} service, VSCode is the preferred IDE. In each DRL rule file, you define rule conditions, actions, and other components related to the rule, based on the data objects you create or import in the package.

.Prerequisite
* You have created a {PRODUCT} project and have included any Java data objects required for your {PRODUCT} service. For information about creating a project, see
ifdef::KOGITO[]
{URL_CREATING_RUNNING}[_{CREATING_RUNNING}_].
endif::[]
ifdef::KOGITO-COMM[]
xref:chap_kogito-creating-running[].
endif::[]

.Procedure
. In your VSCode IDE, create or import a DRL file in the relevant folder of your {PRODUCT} project, typically in `src/main/resources`.
. Define the DRL file with any of the following components.
+
At a minimum, each DRL file must specify the `package`, `import`, and `rule` components. All other components are optional.
+
.Components in a DRL file
[source,subs="attributes+"]
----
package
unit  // Recommended

import

declare   // Optional

query  // Optional

rule "rule name"
    // Attributes
    when
        // Conditions
    then
        // Actions
end

rule "rule2 name"

...

----
+
* `package`: Use this to specify the location of the Java data objects in your project, typically the sub-directory path in `src/main/java`.
+
.Specifying a package
[source]
----
package org.mortgages
----
+
* `unit`: Use this to associate this rule file with a rule unit. A DRL rule unit is a module for rules and a unit of execution. A rule unit collects a set of rules with the declaration of the type of facts that the rules act on. A rule unit also serves as a unique namespace for each group of rules. A single rule base can contain multiple rule units. You typically store all the rules for a unit in the same file as the unit declaration so that the unit is self-contained.
+
.Declaring a rule unit
[source]
----
unit MortgageRules
----
+
* `import`: Use this to identify specific data objects from the package that you want to use in the DRL file. Specify the package and data object in the format `packageName.objectName`, with multiple imports on separate lines.
+
--
.Importing data objects
[source]
----
import org.mortgages.LoanApplication;
----

For DRL rule units, you also use the `import` statement to declare the relevant data source from your rule unit class (`DataStream`, `DataStore`, `SingletonStore`):

.Importing data source type for DRL rule unit
----
import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;
----
--
* `declare`: (optional) Use this to declare a new fact type to be used by rules in the DRL file. The default fact type in the `java.lang` package of {PRODUCT} is `Object`, but you can declare other types in DRL files as needed. Declaring fact types in DRL files enables you to define a new fact model directly in the {DECISION_ENGINE}, without creating models in a lower-level language like Java.
+
--
.Declaring and using a new fact type
[source]
----
declare Person
  name : String
  dateOfBirth : java.util.Date
  address : Address
end

rule "Using a declared type"
  when
    $p : /person[ name == "James" ]
  then   // Insert Mark, who is a customer of James.
    Person mark = new Person();
    mark.setName( "Mark" );
    person.add( mark );
end
----

For DRL rule units, you declare the fact types in a separate DRL file that functions as a rule unit class and then implement the declarations through the relevant data sources in the DRL rule file:

.Example DRL rule unit class to define declarations
[source]
----
package org.mortgages;

declare Person
    name : String
    dateOfBirth : Date
    address : Address
end
----

.Example DRL rule file to implement rule unit and declarations
[source]
----
package org.mortgages;
unit MortgageRules;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

declare MortgageRules extends RuleUnitData
  person: DataStream<Person> = DataSource.createStream()
end

rule "Using a rule unit with a declared type"
  when
    $p : /person[ name == "James" ]
  then   // Insert Mark, who is a customer of James.
    Person mark = new Person();
    mark.setName( "Mark" );
    person.add( mark );
end
----
--
* `query`: (optional) Use this to search the {DECISION_ENGINE} for facts related to the rules in the DRL file. You add the query definitions in DRL files and then obtain the matching results in your application code. Queries search for a set of defined conditions and do not require `when` or `then` specifications. Query names are scoped to the rule unit, so each query name must be unique within the same rule unit. In {PRODUCT}, queries are automatically exposed as REST endpoints.
+
--
.Example query definition in a DRL file
[source]
----
query underAge
    person : /person[ age < 21 ]
end
----
--
* `rule`: Use this to define each rule in the DRL file. Rules consist of a rule name in the format `rule "name"`, followed by optional attributes that define rule behavior (such as `salience` or `no-loop`), followed by `when` and `then` definitions. Each rule must have a unique name within the rule package. The `when` part of the rule contains the conditions that must be met to execute an action. For example, if a bank requires loan applicants to have over 21 years of age, then the `when` condition for an `"Underage"` rule would be `/applicant[ age < 21 ]`. The `then` part of the rule contains the actions to be performed when the conditional part of the rule has been met. For example, when the loan applicant is under 21 years old, the `then` action would be `setApproved( false )` based on the defined data source, declining the loan because the applicant is under age.
+
--
.Rule for loan application age limit
[source]
----
rule "Underage"
  salience 15
  when
    $application : /loanApplication
    /applicant[ age < 21 ]
  then
    $application.setApproved( false );
    $application.setExplanation( "Underage" );
end
----

The following example is a complete DRL rule unit set in a loan application decision service. The example includes the DRL rule unit class with type declarations and the DRL rule file with the implemented rule unit, declarations, and data sources.

.Example DRL rule unit class to define declarations
[source]
----
package org.mortgages;

declare Bankruptcy
    yearOfOccurrence: double
    amountOwed: double
end

declare Applicant
    age: double
end

declare LoanApplication
  setApproved: boolean
  setExplanation: string
end
----

.Example DRL rule unit file for a loan application
[source]
----
package org.mortgages;
unit MortgageRules

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

declare MortgageRules extends RuleUnitData
  bankruptcy: DataStream<Bankruptcy> = DataSource.createStream()
  applicant: DataStream<Applicant> = DataSource.createStream()
  application: DataStream<LoanApplication> = DataSource.createStream()
end

rule "Bankruptcy history"
	salience 10
	when
		$a : /loanApplication
		exists (/bankruptcy[ yearOfOccurrence > 1990 || amountOwed > 10000 ])
	then
		$a.setApproved( false );
		$a.setExplanation( "has been bankrupt" );
		loanApplication.remove( $a );
end

rule "Underage"
	salience 15
	when
		$application : /loanApplication
		/applicant[ age < 21 ]
	then
		$application.setApproved( false );
		$application.setExplanation( "Underage" );
		loanApplication.remove( $a );
end
----
--
. After you define all components of the rule, save the file in `.drl` format.

.Additional resources
* xref:con_drl-rule-units_drl-rules[]
* xref:con_drl-rules-conditions_drl-rules[]
* xref:con_drl-rules-actions_drl-rules[]
